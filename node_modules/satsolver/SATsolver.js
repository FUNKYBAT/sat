exports.solve = function (fileName) {
    let formula = readFormula(fileName)//Lê a formula.
    let result
    var sizeLimit = formula.variables.length//Recebe o tamanho da formula apenas para termos uma condição de parada dentro do while.
    result = doSolve(formula.clauses, formula.variables, sizeLimit)//Vai tentar resolver de fato o négocio.
    if (result.isSat) {//Soltem os fogos, deu tudo certo.
        console.log("É satisfatível")
        if (formula.infelizmenteDeuRuim != true) {
            console.log("Caso satisfatório: " + result.satisfyingAssignment)
        }
    } else {//Deu ruim, foi triste.
        console.log("Não é satisfatível")
    }
    return result
}

function doSolve(clauses, assignment, sizeLimit) {
    let isTrue//Vai testar as validades de uma clausula em especifico.
    let forNowEverthingIsFine = false//Este deve permanecer true até o final para que seja satisfativel.
    while ((!forNowEverthingIsFine) && (assignment.length == sizeLimit)) {
        //Se forNowEverthingIsFine for verdadeiro o while deve parar, pois significa que deu tudo certo e foi achado a combinação que satisfaz tudo.
        //Se o tamanho do caso teste for maior que o tamanho limite de casos teste, significa que inclusive a situação de tudo true foi testada.
        forNowEverthingIsFine = true//Por enquanto nada começou, então esta tranquilo.
        for (a = 0; a < clauses.length; a++) {
            isTrue = false//Este aq começa já falso, até que se prove o contrário.
            for (b = 0; b < clauses[a].length; b++) {
                //Se isTrue for verdadeiro, significa que aquela clausula é verdadeira para o caso teste, logo, não precisa testar o resto da clausula.
                //Há duas condições para que uma clausula seja verdadeira, primeiro é que o numero da clausula seja maior que 0 e a variável testada seja true.
                //A segunda é que o número da clausula seja menor que 0 e a variável testada seja falsa.
                if (isTrue == false && (clauses[a][b] > 0 && assignment[Math.abs(clauses[a][b]) - 1] == true)) {
                    isTrue = true
                } else if (isTrue == false && (clauses[a][b] < 0 && assignment[Math.abs(clauses[a][b]) - 1] == false)) {
                    isTrue = true
                }
            } if (isTrue == false) {//Se chegar aqui ainda falso, é que uma clausula deu falsa, logo a sentença não se torna verdadeira naquele caso teste.
                forNowEverthingIsFine = false
            }
        } if (forNowEverthingIsFine == false) {//Deu ruim, testa o proximo caso teste.
            assignment = nextAssignment(assignment)
        }
    }
    let result = { 'isSat': forNowEverthingIsFine, satisfyingAssignment: null }
    if (forNowEverthingIsFine && assignment.length == sizeLimit) {
        result.satisfyingAssignment = assignment//Caso que satisfez tudo.
    }
    return result
}

function readFormula(fileName) {
    const fs = require('fs')
    let text = fs.readFileSync(fileName, 'utf8').split(/[\r\n]+/)//Recebe o troço tirando as quebras de linha.
    let clauses = readClauses(text)//Lê as clausulas.
    let variables = readVariables(clauses)
    let specOk = checkProblemSpecification(text, variables, clauses)//Testa os valores.
    let result = { 'clauses': [], 'variables': [], 'infelizmenteDeuRuim': false }
    if (specOk) {//Se for true o programa pode seguir em frente.
        result.clauses = clauses
        result.variables = variables
        result.infelizmenteDeuRuim = false
        return result
    } else {//Se entrar aq foi triste.
        result.infelizmenteDeuRuim = true
        return result
    }

}

function readClauses(text) {
    var array = []//Esse array será preenchido sem as linhas que iniciam com c ou p.
    for (a = 0; a < text.length; a++) {//Percorre o texto recebido.
        if (text[a].charAt(0) == 'c') {//Remove as linhas que iniciam com c.
            continue
        } else if (text[a].charAt(0) == 'p') {//Remove as linhas que iniciam com p.
            continue
        } else {
            let qualquercoisa = text[a].replace(" 0", "")//Pega o trecho final, ou seja, o " 0" e remove.
            array.push(qualquercoisa)//Manda para o array a linha em questão (que não terá c ou p no começo) sem o " 0" que foi removido na linha anterior.
        }
    }
    var arrayPreencher = []//Array que ira receber o split do array com as linhas que não começam com c ou p e que não tem " 0" no final.
    for (a = 0; a < array.length; a++) {//Percorre o array.
        arrayPreencher.push(array[a].split(" "))//Preenche o arrayPreencher com o split de cada elemento do array.
    }
    return arrayPreencher//Devolve o array de clausulas pronto (com o split de todas as linhas que não iniciam com c ou p, sem o " 0" no final).
}

function readVariables(clauses) {
    var array = []//Recebe as clausulas para que através delas o codigo possa verificar as variaveis.
    var arrayVariaveis = []//Array que será preenchido com as variáveis.
    var test//Recebe o valor absoluto do conteudo das clausulas para que sejam comparados com o array de variaveis.
    for (a = 0; a < clauses.length; a++) {//Percorre o array de clausulas.
        array = clauses[a]
        for (b = 0; b < array.length; b++) {//Percorre os arrays em cada possição de clausulas.
            test = Math.abs(array[b])//Põe o valor absoluto de uma variavel para ver se ela já esta ou não no array de variaveis.
            if (arrayVariaveis.indexOf(test) === -1) {
                arrayVariaveis.push(test)//Caso na verificação acima seja averiguado que aquele numero não está no array de variavéis, o número é adicionado ao array de variáveis.
            }
        }
    }
    arrayVariaveis.sort(function (a, b) { return a - b })//Organiza o array.
    for (a = 0; a < arrayVariaveis.length; a++) {
        arrayVariaveis[a] = false//Transforma todas as posições dele em false.
    }
    return arrayVariaveis
}

function checkProblemSpecification(text, variables, clauses) {
    var elemento = 6//Ponto em que inicia a contagem do numero de variáveis.
    var numeroVariaveisString = ''//Como o número pode ser de dois algarismos como 10 ou 20, preferi formar um string concatenando até chegar um espaço vazio.
    var numeroClausulasString = ''
    var numeroVariaveis
    var numeroClausulas
    for (a = 0; a < text.length; a++) {//Percorre o texto com a formatação original.
        if (text[a].charAt(0) == 'p') {//Faz a busca pelo P.
            while (text[a].charAt(elemento) != ' ') {//Continua a busca para formar o número de fato de váriaveis.
                numeroVariaveisString = numeroVariaveisString + text[a].charAt(elemento)//Concatena os algarismos.
                elemento++//Vai para o próximo elemento para verificar se tem o que concatenar.
            }
            elemento++
            while (text[a].charAt(elemento) != '') {
                numeroClausulasString = numeroClausulasString + text[a].charAt(elemento)//Concatena os algorismos. 
                elemento++//Vai para o próximo elemento para verificar se tem o que concatenar.
            }
        }
    }
    numeroVariaveis = parseInt(numeroVariaveisString)//Transforma o string correspondente a variáveis em inteiro.
    numeroClausulas = parseInt(numeroClausulasString)//Transforma o string correspondente a clausulas em inteiro.
    var ok = false
    if (numeroVariaveis == variables.length && numeroClausulas == clauses.length) {
        return ok = true//Retorna isso caso o numero obtido de variáveis e clausulas seja igual ao valor do texto.
    }
    return ok = false
}

function nextAssignment(currentAssignment) {
    for (a = 0; a < currentAssignment.length; a++) {//Roda a configuração atual das variáveis para transformar os trues em 1s e os falses em 0s.
        currentAssignment[a] = currentAssignment[a] == true ? 1 : 0
    }
    let numBINstring = currentAssignment.join('')//Transforma o array da configuração atual em um string de binario.
    let numDEC = parseInt(numBINstring, 2)//Converte a string de binario para um inteiro decimal.
    numDEC++//Soma um a esse decimal.
    let numBIN = numDEC.toString(2)//Converte para um string de binario de novo.
    while (numBIN.length < currentAssignment.length) {//Completa a string por concatenação.
        numBIN = "0" + numBIN
    }
    let newAssignment = numBIN.split('')//Separa o négocio, criando um array de 1s e 0s.
    for (a = 0; a < newAssignment.length; a++) {//Converte os 1s para trues e os 0s para falses.
        newAssignment[a] = newAssignment[a] == 1 ? true : false
    }
    return newAssignment//Retorna a nova configuração.
}